My solution to Jane Street puzzle (Oct 2020 - Candy Collectors): [link](https://www.janestreet.com/puzzles/candy-collectors/)

# Commentary
Initially I thought, if I was living in pre-computer era how would I approach the problem? I got a large paper and started solving the problem for 2 (2 people - 2 candy) and 3.
It became clear that there wont be a simple closed-form solution. Still, I did really get into character as a pre-computer era scholar:

<img src="https://raw.githubusercontent.com/ImanHosseini/MiscWritings/main/Puzzles/JaneStreet/Oct_2020/byhand.jpg" width="600">

Then I implemented the machinery by which I solved the small cases by hand, the same thing just automated. For a specific handout of candies represent it using a 5x5 matrix where element (i,j) denotes how many candies of type j the i'th kid has got. The possible handouts constrain the set of 5x5 matrices to the cases where each row and each column sum to 5, among which we can further exploit the symmetry between kids (the fact that the kids are _indistinguishable_) to restrict ourself to matrices such that the i_th person has a strict majority of the i_th candy, then we can multiply the number of configurations by 5! to take the permutations into account. Also notice that there is _almost_ a duality here with respect to kids/candies: the set of acceptable matrices is closed under transposition right? Think of it as if the kids are being distributed to the candies instead, should be same _unless_ the word *STRICT* comes into play: [2, 2, 1, 0, 0] can be correct as the first row (as long as no other person gets 2 of candy type 1) but it cannot be a correct column because it would imply that there is no one person with a strict majority of candy type 1 (it's a tie).

# Solution (And some insight for general case of N-kid-candy)

So my solution was to enumerate possible _winning_ rows where the 1st element is the major value, like [3, 1, 1, 0, 0] and then generate possible matrices (modulo the symmetries discussed above) via those rows (for i'th row, we pick one of the enumerated _winning_ rows and shift it (i-1) times to get the _major_ value to the correct spot) and then weed out the possible inadmissible matrices, and then for each matric multiply by 5! to account for permutations _AND_ there is another factor we have to consider: when handing out candies, there are 25 candies and then the possible _handouts_ coalesce into equivalent classes based on a given distribution: e.g. we have a row [4, 1, 0, 0, 0] how many ways could the kid get these candies? We have to pick 4 of candy of type 5, and 1 of type 2 so it is possible in 5\*5 ways. Similarly it can be calculated for any matrix by successive applications of this, and the total possible configurations (the denominator, in the fraction which is our probability) are: T = binom(25,5)\*binom(20,5)\*binom(15,5)\*binom(10,5) where binom(n,x) is the number of ways to pick x of n items (aka. binomial coefficient). This product can be reformatted into a more aestheticly pleasing form as: 25!/(5!)^5 or for N: (N^2)!/(N!)^N for N->infinity we can apply Stirling's approximation to get T ~ N^(N^2) Using Python Fraction facility we arrive at 318281087/8016470462, before submitting I ran a [experiment](https://github.com/ImanHosseini/MiscWritings/tree/main/Puzzles/JaneStreet/Oct_2020/pn.py) to verify it was in the right ballpark.

Anyhow, the [code](https://github.com/ImanHosseini/MiscWritings/tree/main/Puzzles/JaneStreet/Oct_2020/puzzle.py) is done in python and I first enumerated the winning rows by hand, but later [implemented](https://github.com/ImanHosseini/MiscWritings/tree/main/Puzzles/JaneStreet/Oct_2020/hello.ml) it - only the enumeration of winning rows - in OCaml (you know, that language jane street likes?) and in fact it is fun to do in functional paradigm, slickly done using _fold_ and pattern matching. The running time for the general N-kid-candy case is obvious from the telescoping for loops, it is K^N where K is the number of possible winning rows. Now for a given N what is K(N)? 

Imagine we want to make a winning row with the major element being Q so: [Q, X_2, X_3, .. X_N] where we haven't decided on the X_i, how many ways can we do this? It is equivalent to number of integer solutions to X_2 + X_3 +.. + X_N = N - Q where X_i >= 0, which is binom(2N - Q - 2, N - 2) and Q goes from N/2 to N so K(N) = sum_Q{binom(2N-Q-2,N-2)} this is 1/2 of the sum over Q = 0 up to Q = N (we are doing asymptotic calculations here, let's be liberal with hand-waving factors away) the terms in the sum are monotnoic, from the smallest being 1 and largest being (via Stirling approx) 2^2N so we can safely say the sum is bounded by N*2^N thus running time would be: O(N^N * 2^(N^2)) which is as bad as you may want for large N!

# Afterthought
Something which I wonder is, even though there is no closed form solution for general p(N), what does p(N) look like asymptotically (for large N) ? I tried to come up with some non-trivial upper-bound / lower-bound and find the asymptotic relation, I may update here with my findings. 

\[ update, 13 December \] : I showed that for large N, the probability goes like 0.649^(N^2). Derivation [here](https://github.com/ImanHosseini/MiscWritings/tree/main/Puzzles/JaneStreet/Oct_2020/Asymptotic_Behavior_of_Candy_Collectors.pdf).
